# Fields

> 'Capture Attribute' nodes are inserted automatically when required

Be sure to be familiar with fields: [Blender reference documentation](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/fields.html).

## Geometry property

Fields such as [Index](/docs/nodes/Index.md) or [Position](/docs/nodes/Position.md)
represents a value (Integer, Float, Vector...) associated to a domain (Point, Edge,...) of a geometry.

In a Blender tree, the geometry a field belongs to is found by following the links forwards and backwards (see [Blender Field](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/fields.html)).

> A field is a geometry property

In **geonodes**, fields are implemented as properties of class Geometry.
In the following example (extracted from
[Blender documentation](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/fields.html#field-context)),
we use two fields of input geometry: [Index](/docs/nodes/Index.md) and the [Position](/docs/nodes/Position.md).

```python
import geonodes as gn

with gn.Tree("Geometry Nodes") as tree:
    
    geo = tree.input_geometry
    
    v = geo.position
    v = v.scale(scale=geo.index)
    
    geo.set_position(offset=v, node_color="green")
    
    tree.output_geometry = geo
```

In the resulting tree, Position and Index nodes are fields of the input geometry because their links "join" at the green node 'Set Position':

<img src="/docs/images/fields_tree_1.png" height="250">

Let's add another 'Set Position' node after the second one, fed by the same offset input. This second node is colored in blue.

```python
import geonodes as gn

with gn.Tree("Geometry Nodes") as tree:
    
    geo = tree.input_geometry
    
    v = geo.position
    v = v.scale(scale=geo.index)
    
    geo.set_position(offset=v, node_color="green")
    geo.set_position(offset=v, node_color="blue")
    
    tree.output_geometry = geo
```

**THE RESULTING TREE IS NOT THE FOLLOWING**

<img src="/docs/images/fields_tree_2.png" height="250">

In the tree above, the fields **Index** and **Position** are evaluated twice, one for the green node and one for the blue node. These two nodes are fed by two different geometries, hence the fields **Index** and **Position** take different values.

The tree resulting from the second script is the following:

<img src="/docs/images/fields_tree_3.png" height="250">

Since the python script defined the `index` and `position` as property of the initial geometry (`v = geo.position`), it understand that a 'Capture Attribute' node is necessary to feed the blue node.

On the illustration below, we can see the three resulting meshes with the same default cube as input:

<img src="/docs/images/fields_comp.png" width="500">


## 'Capture Attribute' insertion

**geonodes** module inserts 'Capture Attribute' nodes whenever required. As a consequence the second tree will never be generated by **geonodes**:

<img src="/docs/images/fields_tree_2.png" height="250">

To produce this result, you must explicitly get the `index` and `position` of the transformed geometry as illustrated below:

```python
import geonodes as gn

with gn.Tree("Geometry Nodes") as tree:
    
    geo = tree.input_geometry
    
    # Fields from the initial geometry
    
    v = geo.position
    v = v.scale(scale=geo.index)
    
    geo.set_position(offset=v, node_color="green")

    # Fields from the transformed geometry
    
    v = geo.position
    v = v.scale(scale=geo.index)

    geo.set_position(offset=v, node_color="blue")
    
    tree.output_geometry = geo
```

The resulting tree is the following.

<img src="/docs/images/fields_tree_4.png" width="700">

There is not anymore 'Capture Attribute' node because it is useless, but there are now two 'Index' nodes and two 'Position' nodes, one for each geometry.




